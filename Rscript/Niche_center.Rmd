---
title: "Niche-Center"
author: "Paanwaris Paansri"
date: "2025-06-03"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "")
options(rgl.useNULL = TRUE)  # Prevent RGL display issues
```

```{r}
library(terra)         # Spatial data handling
library(spThin)        # Spatial thinning of occurrence data
library(pgirmess)      # Spatial autocorrelation functions
library(hypervolume)   # Hypervolume estimation
library(rworldmap)     # World map data
library(gtools)        # Miscellaneous functions, used for 'mixedsort'
library(maps)          # Map plotting
library(tidyverse)
library(ncdf4)
library(sf)
library(usdm) 
library(ellipsenm)
library(vegan)
library(plotly)
library(geodata)
library(RColorBrewer)
library(ggpmisc)
library(lubridate)
library(rnaturalearth)
```

```{r}
pero_merge <- read_csv("/dat_neon_gbif_pero.csv") %>%
  distinct(decimalLongitude, decimalLatitude, .keep_all = TRUE)

# Convert Vic data to spatial vector (terra object)
pero_merge_vec <- vect(pero_merge,
                geom = c("decimalLongitude", "decimalLatitude"),
                crs = "epsg:4326", 
                keepgeom = FALSE)

```

```{r}
pero_buffer <- buffer(pero_merge_vec, width = 200000)
pero_buffer <- aggregate(pero_buffer)
plot(pero_buffer)

# res=0.5 corresponds to 30 seconds
bioclim_full <- worldclim_global(var = "bio", res = 0.5, path = tempdir())

# Exclude the specified layers
cat("Excluding BIO8, BIO9, BIO18, and BIO19...\n")
vars_to_exclude <- c("bio8", "bio9", "bio18", "bio19")
# Get the names of all layers, remove the ones to exclude
layer_names <- names(bioclim_cropped)
vars_to_keep <- layer_names[!grepl(paste(vars_to_exclude, collapse = "|"), layer_names)]

bioclim_final <- subset(bioclim_cropped, vars_to_keep)

# Crop the global raster to your study area
bioclim_cropped <- crop(bioclim_final, pero_buffer, mask = TRUE)

pca <- prcomp(bioclim_cropped, scale. = TRUE)

# --- Step 4: Predict PCA Scores onto the Raster ---
# This projects the PCA model back into geographic space
pca_raster <- predict(bioclim_cropped, pca, index = 1:3)

# Rename the PCA layers for clarity, as requested
names(pca_raster) <- paste0("PC", 1:3)
plot(pca_raster)
```

```{r}
# Clean and prepare the occurrence locations
locs <- pero_merge %>%
  dplyr::select(species, decimalLongitude, decimalLatitude) %>%
  na.omit()

# Extract the bioclimatic values
bioclim_values <- terra::extract(pca_raster, pero_merge_vec)

# Combine extracted data with species data and clean up
# The first column from extract is an ID, so we remove it [,-1]
full_data <- cbind(as.data.frame(pero_merge_vec), bioclim_values) %>% 
  na.omit()

# Step 5: Generate Ellipsoids
# Your function to generate ellipsoid points based on a center and covariance matrix
generate_ellipsoid <- function(center, covariance, confidence_level = 0.95) {
  df <- length(center)
  chi_sq_quantile <- qchisq(confidence_level, df)
  eig <- eigen(covariance)
  eigenvalues <- eig$values
  eigenvectors <- eig$vectors
  scaling_factors <- sqrt(chi_sq_quantile * eigenvalues)
  u <- seq(0, 2 * pi, length.out = 50)
  v <- seq(0, pi, length.out = 50)
  sphere_x <- outer(cos(u), sin(v))
  sphere_y <- outer(sin(u), sin(v))
  sphere_z <- outer(rep(1, length(u)), cos(v))
  unit_sphere <- cbind(as.vector(sphere_x), as.vector(sphere_y), as.vector(sphere_z))
  scaled_sphere <- unit_sphere %*% diag(scaling_factors)
  rotated_sphere <- scaled_sphere %*% t(eigenvectors)
  ellipsoid_points <- as.data.frame(rotated_sphere + rep(center, each = nrow(rotated_sphere)))
  return(ellipsoid_points)
}

# --- 5a. Genus-level "fundamental niche" ellipsoid ---
genus_pcs <- full_data %>% dplyr::select(PC1, PC2, PC3)
genus_centroid <- colMeans(genus_pcs)
genus_cov <- cov(genus_pcs)
genus_ellipsoid <- generate_ellipsoid(genus_centroid, genus_cov, confidence_level = 0.95)
colnames(genus_ellipsoid) <- c("PC1", "PC2", "PC3")

# --- 5b. Species-specific ellipsoids ---
species_list <- unique(full_data$species)
ellipsoid_list <- list()
# Create an empty list to store the centroids before the loop
centroid_list <- list()

for (sp in species_list) {
  species_subset <- full_data %>% # Assuming your data is in `data_with_pcs`
    filter(species == sp) %>%
    dplyr::select(PC1, PC2, PC3)

  # A species needs at least 4 points to calculate a 3D covariance matrix.
  if (nrow(species_subset) > 6) {
    center <- colMeans(species_subset)
    
    # --- ADDITION: Store the calculated centroid ---
    # We convert the center vector to a data frame and add the species name
    centroid_list[[sp]] <- as.data.frame(t(center)) %>% 
      mutate(species = sp)
    # ---------------------------------------------

    covariance <- cov(species_subset)
    ellipsoid_df <- generate_ellipsoid(center, covariance, confidence_level = 0.95)
    colnames(ellipsoid_df) <- c("PC1", "PC2", "PC3")
    ellipsoid_list[[sp]] <- ellipsoid_df
  } else {
    cat(paste("Skipping species '", sp, "' due to insufficient data (<= 6 points).\n", sep=""))
  }
}

# After the loop, combine the list of centroids into a single data frame
all_centroids <- bind_rows(centroid_list)
```

```{r}
pop_data <- read.csv("output/population_All.csv")

# Filter for density estimates and select relevant columns
pop_sites <- pop_data %>%
  na.omit()

# Extract bioclim data for these site coordinates
site_coords <- pop_sites %>% dplyr::select(decimalLongitude, decimalLatitude)
site_pc_scores <- terra::extract(pca_raster, site_coords, fun = NULL)
site_pc_scores_df <- as.data.frame(site_pc_scores[,-1])
colnames(site_pc_scores_df) <- colnames(site_pc_scores_df)

# Combine the population estimates with their new PC scores
pop_total_datsite <- cbind(pop_sites, site_pc_scores_df) %>%
  na.omit()
```


```{r}
# Define a color palette for the species
# *** THIS IS THE UPDATED SECTION FOR 35+ COLORS ***
# 1. Create a palette-generating function from a good base palette
get_palette <- colorRampPalette(brewer.pal(12, "Paired"))
# 2. Generate the exact number of colors needed
num_species <- length(ellipsoid_list)
species_colors <- get_palette(num_species)
# 3. Create a named map to assign colors to species
color_map <- setNames(species_colors, names(ellipsoid_list))

fig <- plot_ly()

# Add all occurrence points as a grey background
fig <- fig %>% add_trace(
  data = full_data,
  x = ~PC1, y = ~PC2, z = ~PC3,
  type = 'scatter3d',
  mode = 'markers',
  marker = list(size = 1.5, color = 'grey'),
  opacity = 0.8,
            connectgaps = TRUE,
  name = 'All Occurrences'
)

# Add the main genus-level ellipsoid
fig <- fig %>% add_trace(
  data = genus_ellipsoid,
  x = ~PC1, y = ~PC2, z = ~PC3,
  type = 'scatter3d', 
  mode = 'lines',
  line = list(width = 5, color = "darkblue", shape = "spline"),
  connectgaps = TRUE,
  opacity = 0.3,
  name = 'Genus Niche (Peromyscus)'
)

# Add each species-specific ellipsoid with a unique color
for (sp in names(ellipsoid_list)) {
  fig <- fig %>% add_trace(
    data = ellipsoid_list[[sp]],
    x = ~PC1, y = ~PC2, z = ~PC3,
    type = 'scatter3d', 
    mode = 'lines',
    line = list(size = 1, color = color_map[[sp]], shape = "spline"),
    opacity = 0.2,
    name = sp,
    showlegend = TRUE
  )
}

# *** NEW: Add the species centroids ***
fig <- fig %>% 
  add_trace(data = all_centroids, 
            x = ~PC1, y = ~PC2, z = ~PC3,
            type = 'scatter3d', 
            mode = 'markers',
            marker = list(size = 5, color = ~color_map,
                          line = list(color = 'black', width = 5)),
            name = 'Species Centroids', 
            showlegend = TRUE)

# *** NEW: Add the overall genus centroid ***
fig <- fig %>% 
  add_trace(x = ~genus_centroid[1], y = ~genus_centroid[2], z = ~genus_centroid[3],
            type = 'scatter3d', 
            mode = 'markers',
            marker = list(size = 8, color = 'black', symbol = 'diamond'),
            name = 'Genus Centroid', showlegend = TRUE)

# Customize the plot layout
fig <- fig %>% layout(
  title = "3D Environmental Niche Space for the Genus Peromyscus",
  scene = list(
    xaxis = list(title = "PC1"),
    yaxis = list(title = "PC2"),
    zaxis = list(title = "PC3")
  ),
  legend = list(title = list(text = '<b>Species</b>'))
)

# --- NEW: Add the population size markers ---
fig <- fig %>% 
  add_trace(data = pop_total_datsite, 
            x = ~PC1, y = ~PC2, z = ~PC3,
            type = 'scatter3d',
            mode = 'markers',
            marker = list(size = ~sqrt(estimate)/4,
                          color = 'red',
                          opacity = 0.8),
            name = 'Population Density', showlegend = TRUE)

# Print the figure to display it
fig
```

```{r}
# --- Step 1: Calculate Distances to Centroids ---

# Ensure the required data frames from the previous steps are available:
# - pop_total_datsite: Population sites with their PC scores
# - genus_centroid: A named vector with PC1, PC2, PC3 for the genus
# - all_centroids: A data frame with PC1, PC2, PC3 for each species

# Helper function for Euclidean distance in 3D
euc_dist <- function(p1, p2) {
  sqrt(sum((p1 - p2)^2))
}

# 1a. Calculate distance for each site to the GENUS centroid
pop_total_datsite$dist_to_genus_centroid <- apply(
  pop_total_datsite[, c("PC1", "PC2", "PC3")], 1, 
  function(site_coords) {
    euc_dist(site_coords, genus_centroid)
  }
)

# --- Step 2: Create the Plots ---

# 2a. Plot 1: Abundance vs. Distance to GENUS Centroid
plot_genus <- ggplot(pop_total_datsite, aes(x = dist_to_genus_centroid, y = estimate)) +
  geom_point(size = 4, colour = "#0072B2") +
  stat_poly_line(formula = y ~ log(x), colour = "black", fill = "#D55E00", alpha = 0.3) +
  stat_poly_eq(
    aes(label = sprintf("%s*\", \"*%s*\", \"*%s",
                        after_stat(rr.label),
                        after_stat(f.value.label),
                        after_stat(p.value.label))),
    formula = y ~ log(x),
    label.y = "top", label.x = "right", size = 5, parse = TRUE
  ) +
  labs(
    x = "Distance to Genus Niche Centroid", 
    y = "Abundance",
    title = "Niche-Abundance Relationship (Genus Level)"
  ) +
  theme_classic() +
  theme(
    text = element_text(family = "serif", size = 14),
    plot.title = element_text(size = 18, face = "bold"),
    axis.title = element_text(size = 16),
    axis.text = element_text(size = 14)
  )

plot_genus

# --- Step 1: Restructure Data for Faceting ---
# (This code is the same as before, assuming you have the necessary data frames)

all_centroids_renamed <- all_centroids %>%
  rename(centroid_species = species)

long_distance_df <- pop_total_datsite %>%
  mutate(key = 1) %>%
  full_join(
    all_centroids_renamed %>% mutate(key = 1),
    by = "key",
    relationship = "many-to-many"
  ) %>%
  dplyr::select(-key)

long_distance_df <- long_distance_df %>%
  rowwise() %>%
  mutate(
    distance = sqrt(
      (PC1.x - PC1.y)^2 + (PC2.x - PC2.y)^2 + (PC3.x - PC3.y)^2
    )
  ) %>%
  ungroup()


# --- Step 2: Create the Corrected Faceted Plot ---

# The formula for the regression equation on the plot
formula <- y ~ log(x)

plot_faceted <- ggplot(long_distance_df, aes(x = distance, y = estimate)) +
  geom_point(size = 2, alpha = 0.6, colour = "#db1049") +
  stat_poly_line(formula = formula, colour = "black", fill = "#ffc20c", alpha = 0.4) +
  
  # --- THIS IS THE CORRECTED SECTION ---
  stat_poly_eq(
    aes(label = paste(after_stat(rr.label), after_stat(p.value.label), sep = "*\", \"*")),
    formula = formula,
    label.y = "top", label.x = "right", size = 3.5, parse = TRUE
  ) +
  # -------------------------------------

  facet_wrap(~ centroid_species, scales = "free_x") +
  labs(
    x = "Euclidean Distance to Species Niche Centroid", 
    y = "Abundance (ind/hectare)",
    title = "Site Abundance vs. Distance to Each Species' Niche Centroid"
  ) +
  theme_bw() +
  theme(
    text = element_text(family = "serif", size = 12),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 10),
    strip.text = element_text(face = "bold.italic", size = 11),
    strip.background = element_rect(fill = "grey90", color = "black")
  )

plot_faceted
```

##R Script to Calculate Temporal occupancy
This script will load your data, parse the eventDate column, assign records to a grid, and then calculate the number of unique years each grid cell has a detection.

```{r}
# Using the "(1)" version of the file as specified
occur_data <- read_csv("data/dat_neon_gbif_pero.csv")

occur_data$datetime <- as.POSIXct(paste0(occur_data$day,'-',
                                         occur_data$month,'-',
                                         occur_data$year),
                                  format = '%d-%m-%Y')
# Clean data, and importantly, parse the date and extract year and month
locs <- occur_data %>%
  dplyr::select(species, decimalLongitude, decimalLatitude, datetime) %>%
  na.omit() %>%
  mutate(
    year = year(datetime),
    month = month(datetime)
  ) %>%
  filter(!is.na(year) & !is.na(month)) %>%
  unite("year_month", year, month, sep = "_", remove = FALSE)

# --- Step 2: Determine Overall Survey Period in MONTHS ---
# Find the total time span of the entire dataset in months
min_date <- min(locs$datetime)
max_date <- max(locs$datetime)

# Calculate the total number of months in the interval
total_survey_months <- interval(min_date, max_date) %/% months(1) + 1

# --- Step 3: Grid the Data and Calculate Monthly Occupancy Frequency ---
grid_resolution <- res(pca_raster)[1]

locs_with_grid <- locs %>%
  mutate(
    grid_lon = floor(decimalLongitude / grid_resolution) * grid_resolution,
    grid_lat = floor(decimalLatitude / grid_resolution) * grid_resolution
  )

# Calculate the new metric for each grid cell
monthly_occupancy_freq_grid <- locs_with_grid %>%
  group_by(grid_lon, grid_lat) %>%
  summarise(
    # Numerator: The number of unique months with detections
    n_unique_months = n_distinct(year_month, na.rm = TRUE),
    
    # The new robust metric
    monthly_occupancy_frequency = n_unique_months / total_survey_months,
    
    mean_lon = mean(decimalLongitude),
    mean_lat = mean(decimalLatitude),
    .groups = 'drop'
  ) %>%
  arrange(desc(monthly_occupancy_frequency))

# --- Step 4: Visualize the Results ---
world_map <- map_data("world")

monthly_occupancy_map <- ggplot() +
  geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
               fill = "gray90", color = "white") +

  geom_tile(data = monthly_occupancy_freq_grid,
            aes(x = grid_lon, y = grid_lat, fill = monthly_occupancy_frequency),
            width = grid_resolution, height = grid_resolution, alpha = 0.9) +

  scale_fill_viridis_c(
    name = "Monthly\nOccupancy\nFrequency",
    option = "plasma",
    labels = scales::percent
  ) +

  coord_fixed(
    xlim = range(locs$decimalLongitude) + c(-2, 2),
    ylim = range(locs$decimalLatitude) + c(-2, 2)
  ) +

  labs(
    title = "Occupancy Frequency of Peromyscus",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_minimal()

print(monthly_occupancy_map)
```

```{r}
# Extract the mean coordinates from the grid cells
occupancy_grid_coords <- monthly_occupancy_freq_grid %>%
  dplyr::select(mean_lon, mean_lat) %>%
  rename(decimalLongitude = mean_lon, decimalLatitude = mean_lat)

# Extract bioclimatic data for these coordinates (assumes 'worldclim_data' is loaded)
occupancy_pca_values <- terra::extract(pca_raster, occupancy_grid_coords, fun = NULL)
occupancy_pca_df <- as.data.frame(occupancy_pca_values[,-1])
colnames(occupancy_pca_df) <- colnames(occupancy_pca_df)

# Create the final data frame for plotting and analysis
occupancy_grid_pca <- cbind(monthly_occupancy_freq_grid, occupancy_pca_df) %>%
  na.omit()
```

```{r}
fig <- plot_ly()

# Add all occurrence points as a grey background
fig <- fig %>% add_trace(
  data = full_data,
  x = ~PC1, y = ~PC2, z = ~PC3,
  type = 'scatter3d',
  mode = 'markers',
  marker = list(size = 1.5, color = 'grey'),
  opacity = 0.8,
            connectgaps = TRUE,
  name = 'All Occurrences'
)

# Add the main genus-level ellipsoid
fig <- fig %>% add_trace(
  data = genus_ellipsoid,
  x = ~PC1, y = ~PC2, z = ~PC3,
  type = 'scatter3d', 
  mode = 'lines',
  line = list(width = 5, color = "darkblue", shape = "spline"),
  connectgaps = TRUE,
  opacity = 0.3,
  name = 'Genus Niche (Peromyscus)'
)

# Add each species-specific ellipsoid with a unique color
for (sp in names(ellipsoid_list)) {
  fig <- fig %>% add_trace(
    data = ellipsoid_list[[sp]],
    x = ~PC1, y = ~PC2, z = ~PC3,
    type = 'scatter3d', 
    mode = 'lines',
    line = list(size = 1, color = color_map[[sp]], shape = "spline"),
    opacity = 0.2,
    name = sp,
    showlegend = TRUE
  )
}

# *** NEW: Add the species centroids ***
fig <- fig %>% 
  add_trace(data = all_centroids, 
            x = ~PC1, y = ~PC2, z = ~PC3,
            type = 'scatter3d', 
            mode = 'markers',
            marker = list(size = 5, color = ~color_map,
                          line = list(color = 'black', width = 5)),
            name = 'Species Centroids', 
            showlegend = TRUE)

# *** NEW: Add the overall genus centroid ***
fig <- fig %>% 
  add_trace(x = ~genus_centroid[1], y = ~genus_centroid[2], z = ~genus_centroid[3],
            type = 'scatter3d', 
            mode = 'markers',
            marker = list(size = 12, color = 'black', symbol = 'diamond'),
            name = 'Genus Centroid', showlegend = TRUE)

# Customize the plot layout
fig <- fig %>% layout(
  title = "3D Environmental Niche Space for the Genus Peromyscus",
  scene = list(
    xaxis = list(title = "PC1"),
    yaxis = list(title = "PC2"),
    zaxis = list(title = "PC3")
  ),
  legend = list(title = list(text = '<b>Species</b>'))
)

# --- NEW: Add the population size markers ---
fig <- fig %>% 
  add_trace(data = occupancy_grid_pca, 
            x = ~PC1, y = ~PC2, z = ~PC3,
            type = 'scatter3d',
            mode = 'markers',
            marker = list(size = ~monthly_occupancy_frequency*200,
                          color = 'red',
                          opacity = 0.8),
            name = 'Temporal occupancy', showlegend = TRUE)

# Print the figure to display it
fig
```

```{r}
# Calculate distance to genus centroid
occupancy_grid_pca$dist_to_genus_centroid <- apply(
  occupancy_grid_pca[, c("PC1", "PC2", "PC3")], 1, 
  function(grid_coords) euc_dist(grid_coords, genus_centroid)
)

# Plot 1: occupancy vs. Distance to GENUS Centroid
plot_occupancy_genus <- ggplot(occupancy_grid_pca, aes(x = dist_to_genus_centroid, y = monthly_occupancy_frequency)) +
  geom_point(size = 2, alpha = 0.3, colour = "#0072B2") +
  stat_poly_line(formula = y ~ log(x), colour = "black", fill = "#0072B2", alpha = 0.3) +
  stat_poly_eq(aes(label = paste(after_stat(rr.label), after_stat(p.value.label), sep = "*\", \"*")), formula = y ~ log(x),
    label.y = "top", label.x = "right", size = 3.5, parse = TRUE
  ) +
  labs(x = "Distance to Genus Niche Centroid", y = "Unique Month of Detection") +
  theme_classic(base_family = "serif", base_size = 14)

plot_occupancy_genus
```

```{r}
# NEW: Group by grid cell AND by species
sp_occupancy_grid <- locs_with_grid %>%
  group_by(grid_lon, grid_lat, species) %>%
  summarise(
    # Numerator: The number of unique months for this species in this cell
    n_unique_months = n_distinct(year_month, na.rm = TRUE),
    
    # The monthly occupancy frequency metric
    monthly_occupancy_frequency = n_unique_months / total_survey_months,
    
    mean_lon = mean(decimalLongitude),
    mean_lat = mean(decimalLatitude),
    .groups = 'drop'
  ) %>%
  arrange(desc(monthly_occupancy_frequency))

# --- Step 2: Join occupancy Data with Niche & Centroid Data ---
# Project grid cell locations into PCA space (uses objects from previous steps)
sp_occupancy_grid_coords <- sp_occupancy_grid %>%
  dplyr::select(mean_lon, mean_lat) %>%
  rename(decimalLongitude = mean_lon, decimalLatitude = mean_lat)
sp_pca_values <- terra::extract(pca_raster, sp_occupancy_grid_coords, fun = NULL)
sp_pca_df <- as.data.frame(sp_pca_values[,-1])
colnames(sp_pca_df) <- colnames(sp_pca_df)

# Combine species occupancy data with the PC scores for each grid cell
sp_occupancy_with_pcs <- cbind(sp_occupancy_grid, sp_pca_df)

# Join the species centroids data (assumes 'all_centroids' is loaded)
# We'll add suffixes to distinguish grid PC scores from centroid PC scores
analysis_df <- sp_occupancy_with_pcs %>%
  left_join(all_centroids, by = "species", suffix = c("_grid", "_centroid"))


# --- Step 3: Calculate Distances and Create Faceted Plot ---
# Calculate distance for each grid cell to its corresponding species' centroid
analysis_df <- analysis_df %>%
  rowwise() %>%
  mutate(
    distance = sqrt(
      (PC1_grid - PC1_centroid)^2 + 
      (PC2_grid - PC2_centroid)^2 + 
      (PC3_grid - PC3_centroid)^2
    )
  ) %>%
  ungroup()

analysis_df_filtered <- analysis_df %>%
  group_by(species) %>%
  filter(n() >= 30) %>%
  ungroup() %>% 
  na.omit()
```

```{r}
# Create the final faceted plot
plot_faceted_species <- ggplot(analysis_df_filtered, aes(x = distance, y = monthly_occupancy_frequency)) +
  geom_point(size = 2.5, alpha = 0.7, colour = "#0072B2") +
  stat_poly_line(formula = y ~ log(x), se = FALSE, color = "black") + # Simplified line
  stat_poly_eq(
    aes(label = paste(after_stat(rr.label), after_stat(p.value.label), sep = "*\", \"*")),
    formula = y ~ log(x),
    label.y = "top", label.x = "right", size = 3, parse = TRUE
  ) +
  # Create one plot panel for each species
  facet_wrap(~ species, scales = "free") +
  labs(
    x = "Distance to Own Species Niche Centroid", 
    y = "Unique Month of Detection"
  ) +
  theme_bw(base_family = "serif") +
  theme(
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    axis.title = element_text(size = 14),
    strip.text = element_text(face = "bold.italic", size = 10),
    strip.background = element_rect(fill = "grey90", color = "black")
  )

plot_faceted_species
```

